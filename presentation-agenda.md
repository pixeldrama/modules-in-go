# Go Modules Presentation Agenda

## 1. Versioning in Go Modules
- Semantic versioning (MAJOR.MINOR.PATCH)
- How Go resolves version conflicts
- Version selection algorithm
- Major Version Support:
  - Each major version is treated as a separate module
  - Module path must include major version (e.g., example.com/mymodule/v2)
  - Import paths must match module path
  - Allows multiple major versions to coexist
  - Example:
    ```go
    // v1 version
    import "example.com/mymodule/pkg"
    
    // v2 version
    import "example.com/mymodule/v2/pkg"
    ```
- Practical examples of version resolution

## 2. Pseudo-Versioning Deep Dive
- What are pseudo-versions?
- Format: `v0.0.0-YYYYMMDDHHMMSS-abcdef123456`
- When are they generated?
  - When referencing a commit without a tag
  - When using `go get` with a commit hash
- Timestamp generation:
  - Comes from the commit's author date
  - Not generated by Go, but extracted from Git
  - Used for chronological ordering
- Example workflow:
  ```bash
  # This command
  go get github.com/pkg/errors@1124e2a89491
  
  # Results in this in go.mod
  require github.com/pkg/errors v0.0.0-20220331215715-1124e2a89491
  ```

## 3. The Replace Directive
- What is the replace directive?
- Common use cases:
  - Local development
  - Testing unreleased changes
  - Working with forks
  - Fixing version conflicts
- Syntax and examples:
  ```go
  // Replace with local path
  replace github.com/pkg/errors => ../errors
  
  // Replace with specific version
  replace github.com/pkg/errors => github.com/pkg/errors v1.2.3
  
  // Replace with fork
  replace github.com/pkg/errors => github.com/your-fork/errors v1.2.3
  ```
- Best practices:
  - Use for development only
  - Document replacements
  - Consider using workspace mode for complex cases

## 4. Practical Examples
- Setting up a new module
- Managing dependencies
- Handling version conflicts
- Using replace for local development
- Working with private modules
- Major version updates:
  - Creating a new branch for v2
  - Updating module path
  - Updating import paths
  - Publishing the new version

## 5. Common Pitfalls and Solutions
- Version conflicts
- Circular dependencies
- Private module access
- Workspace mode vs replace
- Security considerations
- Major version migration challenges:
  - Maintaining multiple versions
  - Supporting old versions
  - User migration path

## 6. Best Practices
- Version pinning
- Dependency management
- Security
- Reproducible builds
- Documentation
- Major version updates:
  - Clear communication with users
  - Support policy for old versions
  - Migration guides
  - Backward compatibility considerations

## 7. Q&A Session
- Common questions
- Troubleshooting
- Real-world scenarios
- Migration strategies
- Major version update strategies

## References and Sources

### Official Go Documentation
- [Go Modules Reference](https://go.dev/ref/mod)
- [Developing a Major Version Update](https://go.dev/doc/modules/major-version)
- [Module Version Numbering](https://go.dev/doc/modules/version-numbers)
- [Publishing a Module](https://go.dev/doc/modules/publishing)
- [Module Release and Versioning Workflow](https://go.dev/doc/modules/release-workflow)

### Additional Resources
- [Go Blog: Using Go Modules](https://go.dev/blog/using-go-modules)
- [Go Blog: Go Modules: v2 and Beyond](https://go.dev/blog/v2-go-modules)
- [Go Blog: Migrating to Go Modules](https://go.dev/blog/migrating-to-go-modules)

### Tools and Commands
- [go mod command documentation](https://go.dev/ref/mod#go-mod)
- [go get command documentation](https://go.dev/ref/mod#go-get)
- [go work command documentation](https://go.dev/ref/mod#go-work) 